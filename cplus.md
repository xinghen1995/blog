## 导航
> #### 第二章 对象的创建和使用
> #### 第十一章 引用和拷贝构造函数
> #### STL容器
> #### 随笔

## 第二章 对象的创建和使用
1. C语言的所有头文件在C++中都用c前缀声明，并省略'.h'的后缀：
```cpp
#include <cstdio>
#include <cstdlib>
```
2. <fstream.h>提供了文件操作的接口，主要式两个流式对象ifstream，ofstream。
3. getline()函数会丢弃换行符，而不是把它存入string对象。
4. 在C++中signed和unsigned比较会产生编译告警，可以使用std::size_t消除告警(for循环)

## 第十一章 引用和拷贝构造函数
1. C++比C对类型的要求更严格。C中可以通过void *隐式的将指针转换为不同的类型，导致潜在的安全问题。而C++要求必须使用强制类型转换。
以下代码在C中可以编译通过，但C++会要求强制类型转换
```cpp
bird *b;
rock *r;
void * v;
v = r;
b = v;
```
2. 引用可以看作特殊的指针，但有一下的使用要求：
    + 当引用被创建时，引用必须被初始化，并和一块内存关联。(可以是局部变量的内存)
    + 引用初始化被指向一个对象之后，不能更改指向另外的对象。而指针可以
    + 不可能存在空引用，必须保证引用是一块合法的内存区域。
3. 对于不变的对象，声明常量引用是很有必要的。因为函数调用过程中，很可能会给函数传递临时变量，临时变量是不允许改变的。
另外，如果给函数传递常量，同时没有声明为常量引用，编译器会报错。因为函数声明为引用，就是要求参数必须和一块内存关联。
```cpp
void f(int& x);
void g(const int& x);
f(1); // Error
g(1); // OK
```
4. C++和C在函数调用的时候，会隐式的将函数返回值压栈，在返回地址之前。主要是为了防止中断或重入导致丢失返回值信息。且函数返回时，将清除所有的局部变量，
如果放在返回地址之后，将可能导致数据丢失、被覆盖等。

5. 传值使用的是传统的位拷贝，不会调用构造函数。

## 随笔
1. 对于C++这种面向对象的语言来说，函数传值必定会调用形参对象的构造函数(退出会调用析构函数)。这就增加了时间的开销，一次对象一般都是传递引用(const引用保证数据不被修改，即常量引用
)

2. C++用template声明泛型
```c++
template <class T, class Ta, class Tb, class Tc>
T abc(const Ta& a, const Tb& b, const Tc& c);
```

3. const引用返回。将返回引用声明为const，和普通的返回是一样的效果，不同在于要求函数返回值只能赋值给const常量。

## STL容器
1. <vector>
    + push_back() 在vector末尾添加一个元素
    + push_frount() 在vector前面加入一个元素
    + 取出元素直接使用书的数组下标，因为vector重载了数组访问运算符